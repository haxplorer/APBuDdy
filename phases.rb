#!/usr/bin/env ruby

require "Classes.rb"

#Checks for GNU Configure script and creates the configure, make and install phases
def gnu_configure_check()
	credit=0
	if FileTest.exist?("#{Sysvars.get_extracted_dir}/configure")
		credit=10
		if FileTest.exist?("#{Sysvars.get_extracted_dir}/configure.in")
		credit+=30
		end
		if (File.new("#{Sysvars.get_extracted_dir}/configure").read=~/Generated by GNU Autoconf/)
		credit+=30
		end
	end
	return credit
end

#Create and fill in the configure phase's contents.
#Does not take care to evaluate the presence of configure.
#The calling function must call it in a suitable way based on the credits.
def generate_configure_phase()
	configure_args = Pkgvars.get_configure_args
	extra_configure_args = Pkgvars.get_extra_configure_args
	if(Pkgvars.get_cflags=="")
		system("export CFLAGS=\"$RPM_OPT_FLAGS\"")
	else
		system("export CFLAGS=\"Pkgvars.get_cflags\"")
	end
        if(Pkgvars.get_cxxflags=="")
                system("export CFLAGS=\"$RPM_OPT_FLAGS\"")
        else
                system("export CFLAGS=\"Pkgvars.get_cxxflags\"")
        end

	steps = "./configure \\"
	configure_args.each_with_index do |arg,i| 
		if (i!=(arg.size-1)||extra_configure_args.size!=0)
			steps.concat("#{arg} \\")
		else
			steps.concat(arg)
		end
	end
        extra_configure_args.each_with_index do |arg,i| 
		if (i!=(arg.size-1))
			steps.concat("#{arg} \\")
                else
			steps.concat(arg)
                end
        end
	configure_phase = Phase.new("gnu_configure",steps)
	return configure_phase
end

#Create and fill in the make phase's contents.
#Does not take care to evaluate the presence of make.
#The calling function must call it in a suitable way based on the credits.

def gnu_make_check()
        credit=0
        if FileTest.exist?("#{Sysvars.get_extracted_dir}/Makefile")
                credit=60
        end
	return credit
end

def generate_make_phase()
	make_args = Pkgvars.get_make_args
	steps = "make "
	make_args.each_with_index do |arg,i| 
		steps.concat("#{arg} ")
	end
	make_phase = Phase.new("gnu_make",steps)
        return make_phase
end

#Create and fill in the install phase's contents.
#Does not take care to evaluate the presence of install.
#The calling function must call it in a suitable way based on the credits.

def gnu_install_check()
        credit=0
        if FileTest.exist?("#{Sysvars.get_extracted_dir}/Makefile")
                credit=30
		if File.new("#{Sysvars.get_extracted_dir}/Makefile").read =~ /install/
                credit+=30
                end
        end
        return credit
end

def generate_install_phase()
	install_args = Pkgvars.get_install_args
	steps = "make "
        install_args.each_with_index do |arg,i| 
		steps.concat("#{arg} ")
        end
	steps.concat("DESTDIR=#{Sysvars.get_rpm_build_root}#{Pkgvars.get_pkg_name} ")
	Pkgvars.set_var("buildroot","#{Sysvars.get_rpm_build_root}#{Pkgvars.get_pkg_name}")
	steps.concat("install")
	install_phase = Phase.new("gnu_install",steps)
        return install_phase
end

def perl_check()
        credit=0
        if FileTest.exist?("#{Sysvars.get_extracted_dir}/Makefile.PL")
                credit=30
		if File.new("#{Sysvars.get_extracted_dir}/Makefile.PL").read =~ /all/
			credit+=30
		end
        end
	return credit
end

def generate_perl_makefile()
        steps = "perl ./Makefile.PL --all "
        perl_phase = Phase.new("perl_configure",steps)
        return perl_phase

end

def generate_getfile_phase(pkg_path=Pkgvars.get_src_path)
	if !FileTest.exist?("#{get_homedir()}/.apbd/PACKAGES/")
		system("mkdir #{get_homedir()}/.apbd/PACKAGES/")
	end
	if FileTest.exist?(pkg_path)
		steps = "cp #{pkg_path} #{get_homedir()}/.apbd/PACKAGES/"
	elsif pkg_path.split("://")[0]=="http" || Pkgvars.get_src_path.split("://")[0]=="ftp"
		steps = "cd #{get_homedir()}/.apbd/PACKAGES; wget #{pkg_path}"
	end
	Tempvars.set_path("#{get_homedir()}/.apbd/PACKAGES/#{File.basename(pkg_path)}")
	getfile_phase = Phase.new("getfile",steps)
	return getfile_phase
end

def generate_unpack_phase(pkg_path=Pkgvars.get_src_path)
        name = File.basename(pkg_path)
        type = name.split(".")[name.split(".").size-1]
        if type=="gz"
                arg = "z"
        elsif type=="bz2"
                arg="j"
        end
        sourcedir = get_sourcedir()
        system("tar -t#{arg}f #{get_homedir()}/.apbd/PACKAGES/#{File.basename(pkg_path)} >/tmp/#{name}.qst")
        system("awk -F \"/\" '{print $1}' /tmp/#{name}.qst | uniq | wc -l >/tmp/#{name}_no_of_folders_in_tar")
        if File.new("/tmp/#{name}_no_of_folders_in_tar","r").gets.to_i>1
                system("rm /tmp/#{name}_no_of_folders_in_tar")
                system("mkdir #{name.split(".")[0]}; cd #{name.split(".")[0]}")
        end
	if pkg_path == Pkgvars.get_src_path
	Sysvars.set_extracted_dir(`cat /tmp/#{name}.qst | awk -F '/' '{print $1}' | uniq`.chomp)
	else
	Tempvars.set_extracted_dir(`cat /tmp/#{name}.qst | awk -F '/' '{print $1}' | uniq`.chomp)
	end
        steps = "cd #{sourcedir};tar -x#{arg}vf #{get_homedir()}/.apbd/PACKAGES/#{File.basename(pkg_path)} >/tmp/#{name}.qsx"
	unpack_phase = Phase.new("unpack",steps)
	return unpack_phase
end

def generate_patch_phase(extracted_dir,n)
	steps = "for each in "
	steps.concat("#{extracted_dir}/*.patch")
	steps.concat("; do patch -p#{n} < $each ; done")
	patch_phase = Phase.new("Patch",steps)
	return patch_phase
end

def generate_merge_source_phase(extra_src_path=Tempvars.get_extracted_dir,main_src_path=Sysvars.get_extracted_dir)
	steps = "cp -a #{extra_src_path}/* #{main_src_path}/"
	merge_source_phase = Phase.new("Merge_Source",steps)
	return merge_source_phase
end

def generate_predefined_phases
	Phase.phase_push(Phase.new("getfile","",0))
	Phase.phase_push(Phase.new("unpack","",0))
	Phase.phase_push(Phase.new("perl_configure","",0))
	Phase.phase_push(Phase.new("gnu_configure","",0))
	Phase.phase_push(Phase.new("gnu_make","",0))
	Phase.phase_push(Phase.new("gnu_install","",0))
end
